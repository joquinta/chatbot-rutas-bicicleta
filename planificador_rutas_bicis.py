# -*- coding: utf-8 -*-
"""Planificador_rutas_bicis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DEw4XYYPsb5xnfTfW6U_BYdbXKEGGTW7
"""

import streamlit as st
from datetime import datetime, timedelta
import json
import requests
import re
from langchain.adapters.openai import convert_openai_messages
from langchain_community.chat_models import ChatOpenAI
import os
from dotenv import load_dotenv

# Cargar variables de entorno
load_dotenv()

# Claves API (definidas en .env o en la configuraci√≥n de Streamlit)
OWM_API_KEY = os.getenv("OWM_API_KEY")
ORS_API_KEY = os.getenv("ORS_API_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Funci√≥n para obtener latitud y longitud con OpenWeatherMap Geocoding API
def obtener_coordenadas(lugar):
    url = f"http://api.openweathermap.org/geo/1.0/direct?q={lugar}&limit=1&appid={OWM_API_KEY}"
    respuesta = requests.get(url).json()
    
    if not respuesta:
        st.warning(f"No se encontraron coordenadas para {lugar}.")
        return None, None
    
    return respuesta[0]["lat"], respuesta[0]["lon"]

# Funci√≥n para obtener la distancia y el tiempo estimado con OpenRouteService
def calcular_distancia_tiempo(puntos):
    coords = [[puntos["inicio"]["lon"], puntos["inicio"]["lat"]]]

    if "intermedios" in puntos and puntos["intermedios"]:
        for intermedio in puntos["intermedios"]:
            coords.append([intermedio["lon"], intermedio["lat"]])

    coords.append([puntos["destino"]["lon"], puntos["destino"]["lat"]])

    url = "https://api.openrouteservice.org/v2/directions/cycling-regular"
    headers = {"Authorization": ORS_API_KEY, "Content-Type": "application/json"}
    data = {"coordinates": coords, "format": "json"}

    respuesta = requests.post(url, headers=headers, json=data).json()
    
    if "routes" not in respuesta:
        st.error("Error en la API de OpenRouteService.")
        return None, None
    
    distancia_total = respuesta["routes"][0]["summary"]["distance"] / 1000  # Convertir a km
    tiempo_total = respuesta["routes"][0]["summary"]["duration"] / 3600  # Convertir a horas

    return distancia_total, tiempo_total

# Funci√≥n para obtener el clima con OpenWeatherMap, eligiendo la hora m√°s cercana hacia arriba
def obtener_clima(lat, lon, fecha_hora):
    url = f"https://api.openweathermap.org/data/2.5/forecast?lat={lat}&lon={lon}&appid={OWM_API_KEY}&units=metric&lang=es"
    respuesta = requests.get(url).json()

    if respuesta.get("cod") != "200":
        return {"temperatura": "N/A", "condiciones": "No disponible"}

    # Filtrar solo pron√≥sticos con timestamps en el futuro (hacia arriba)
    predicciones_futuras = [p for p in respuesta["list"] if datetime.utcfromtimestamp(p["dt"]) >= fecha_hora]

    if not predicciones_futuras:
        return {"temperatura": "N/A", "condiciones": "No disponible"}

    mejor_prediccion = min(predicciones_futuras, key=lambda x: datetime.utcfromtimestamp(x["dt"]))

    return {
        "temperatura": mejor_prediccion['main']['temp'],
        "condiciones": mejor_prediccion["weather"][0]["description"].capitalize()
    }

# Funci√≥n para generar recomendaciones basadas en el clima
def generar_recomendacion(climas):
    recomendaciones = []
    for clima in climas:
        if clima["temperatura"] != "N/A" and clima["temperatura"] > 30:
            recomendaciones.append("Lleva bloqueador solar y bebidas isot√≥nicas por las altas temperaturas.")
        if "lluvia" in clima["condiciones"].lower():
            recomendaciones.append("Lleva chaqueta impermeable y protege tu celular de la lluvia.")
    
    if not recomendaciones:
        return "El clima parece favorable. ¬°Disfruta tu ruta!"
    return " ".join(set(recomendaciones))  # Eliminar duplicados

# Interfaz de Streamlit
st.title("Planificador de Rutas de Bicicleta en Chile üö¥‚Äç‚ôÇÔ∏è")

# Campo de entrada sin mensaje precargado
query = st.text_input("Ingresa tu ruta:", placeholder="Ej: Saldr√© a pedalear el 8 de febrero del 2025 a las 8:00 desde Osorno, pasando por San Pablo y La Uni√≥n, hasta Valdivia.")

if st.button("Planificar Ruta"):
    if not query:
        st.warning("Por favor, ingresa una ruta v√°lida.")
    else:
        # Paso 2: Extraer informaci√≥n clave con OpenAI
        extract_prompt = [
            {"role": "system", "content": "Extrae los siguientes datos en **JSON puro**, sin explicaciones:\n"
             "{\n"
             "  \"hora_salida\": \"YYYY-MM-DD HH:MM\",\n"
             "  \"lugares\": {\n"
             "    \"inicio\": \"Nombre del lugar de inicio\",\n"
             "    \"intermedios\": [\"Nombre del punto intermedio opcional 1\", \"Nombre del punto intermedio opcional 2\"],\n"
             "    \"destino\": \"Nombre del destino final\"\n"
             "  }\n"
             "}"
            },
            {"role": "user", "content": query}
        ]

        lc_messages = convert_openai_messages(extract_prompt)
        response = ChatOpenAI(model='gpt-4', openai_api_key=OPENAI_API_KEY).invoke(lc_messages).content

        match = re.search(r"\{.*\}", response, re.DOTALL)
        if match:
            try:
                extracted_data = json.loads(match.group(0))
            except json.JSONDecodeError:
                st.error("Error al decodificar JSON. Respuesta del modelo: " + response)
                extracted_data = None
        else:
            st.error("No se encontr√≥ JSON en la respuesta del modelo.")
            extracted_data = None

        if not extracted_data:
            st.error("No se pudo extraer la informaci√≥n correctamente.")
        else:
            # Obtener coordenadas de los puntos
            puntos = {"inicio": {}, "destino": {}, "intermedios": []}

            puntos["inicio"]["nombre"] = extracted_data["lugares"]["inicio"]
            puntos["inicio"]["lat"], puntos["inicio"]["lon"] = obtener_coordenadas(puntos["inicio"]["nombre"])

            puntos["destino"]["nombre"] = extracted_data["lugares"]["destino"]
            puntos["destino"]["lat"], puntos["destino"]["lon"] = obtener_coordenadas(puntos["destino"]["nombre"])

            if "intermedios" in extracted_data["lugares"] and extracted_data["lugares"]["intermedios"]:
                for intermedio in extracted_data["lugares"]["intermedios"]:
                    lat, lon = obtener_coordenadas(intermedio)
                    if lat and lon:
                        puntos["intermedios"].append({"nombre": intermedio, "lat": lat, "lon": lon})

            # Calcular distancia y tiempo
            distancia, tiempo_estimado = calcular_distancia_tiempo(puntos)

            # Obtener clima en los puntos clave
            hora_salida = datetime.strptime(extracted_data["hora_salida"], "%Y-%m-%d %H:%M")
            climas = []

            # Clima en el inicio
            clima_inicio = obtener_clima(puntos["inicio"]["lat"], puntos["inicio"]["lon"], hora_salida)
            climas.append({"nombre": puntos["inicio"]["nombre"], "clima": clima_inicio})

            # Clima en los puntos intermedios
            for i, punto in enumerate(puntos["intermedios"]):
                tiempo_parcial = (i + 1) * (tiempo_estimado / (len(puntos["intermedios"]) + 1))
                clima_intermedio = obtener_clima(punto["lat"], punto["lon"], hora_salida + timedelta(hours=tiempo_parcial))
                climas.append({"nombre": punto["nombre"], "clima": clima_intermedio})

            # Clima en el destino
            clima_destino = obtener_clima(puntos["destino"]["lat"], puntos["destino"]["lon"], hora_salida + timedelta(hours=tiempo_estimado))
            climas.append({"nombre": puntos["destino"]["nombre"], "clima": clima_destino})

            # Mostrar resultados de manera org√°nica
            st.success("### Resumen de la ruta:")
            st.write(f"üö¥‚Äç‚ôÇÔ∏è **Distancia total:** {distancia:.2f} km")
            st.write(f"‚è≥ **Tiempo estimado:** {tiempo_estimado:.2f} horas")
            st.write("---")

            st.write("### Clima en los puntos de la ruta:")
            for clima in climas:
                st.write(f"üìç **{clima['nombre']}:** {clima['clima']['condiciones']}, Temperatura: {clima['clima']['temperatura']}¬∞C")
            st.write("---")

            # Generar y mostrar recomendaci√≥n final
            recomendacion = generar_recomendacion([c["clima"] for c in climas])
            st.write("### Recomendaci√≥n:")
            st.info(recomendacion)

