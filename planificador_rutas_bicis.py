# -*- coding: utf-8 -*-
"""Planificador_rutas_bicis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DEw4XYYPsb5xnfTfW6U_BYdbXKEGGTW7
"""

import streamlit as st
from datetime import datetime, timedelta
import json
import requests
import re
from langchain.adapters.openai import convert_openai_messages
from langchain_community.chat_models import ChatOpenAI
import os
from dotenv import load_dotenv
import pytz  # Importa pytz

# Cargar variables de entorno
load_dotenv()

# Claves API (definidas en .env o en la configuraci√≥n de Streamlit)
OWM_API_KEY = os.getenv("OWM_API_KEY")
ORS_API_KEY = os.getenv("ORS_API_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Funci√≥n para obtener latitud y longitud con OpenWeatherMap Geocoding API
def obtener_coordenadas(lugar):
    # Forzar la b√∫squeda en Chile agregando ",cl" al final del lugar
    lugar_busqueda = f"{lugar},cl"
    url = f"http://api.openweathermap.org/geo/1.0/direct?q={lugar_busqueda}&limit=1&appid={OWM_API_KEY}"
    try:
        respuesta = requests.get(url).json()
    except requests.exceptions.RequestException as e:
        st.error(f"Error de conexi√≥n a OpenWeatherMap Geocoding API: {e}")
        return None, None

    if not respuesta:
        st.warning(f"No se encontraron coordenadas para {lugar}.")
        return None, None

    if not isinstance(respuesta, list) or not respuesta:
        st.warning(f"No se encontraron coordenadas para {lugar}.")
        return None, None

    return respuesta[0]["lat"], respuesta[0]["lon"]

# Funci√≥n para obtener la distancia, el tiempo estimado y el desnivel positivo acumulado con OpenRouteService
def calcular_distancia_tiempo(puntos):
    coords = [[puntos["inicio"]["lon"], puntos["inicio"]["lat"]]]

    if "intermedios" in puntos and puntos["intermedios"]:
        for intermedio in puntos["intermedios"]:
            coords.append([intermedio["lon"], intermedio["lat"]])

    coords.append([puntos["destino"]["lon"], puntos["destino"]["lat"]])

    url = "https://api.openrouteservice.org/v2/directions/cycling-regular"
    headers = {"Authorization": ORS_API_KEY, "Content-Type": "application/json"}
    data = {"coordinates": coords, "format": "json", "elevation": True}  # A√±adido "elevation": True

    try:
        respuesta = requests.post(url, headers=headers, json=data).json()
    except requests.exceptions.RequestException as e:
        st.error(f"Error de conexi√≥n a OpenRouteService: {e}")
        return None, None, None

    if not isinstance(respuesta, dict) or "routes" not in respuesta:
        st.error("Error en la API de OpenRouteService.")
        if isinstance(respuesta, dict) and "error" in respuesta:
             st.error(f"Detalles del error: {respuesta['error']}")
        return None, None, None

    try:
        distancia_total = respuesta["routes"][0]["summary"]["distance"] / 1000  # Convertir a km
        tiempo_total = respuesta["routes"][0]["summary"]["duration"] / 3600  # Convertir a horas
        desnivel_positivo = respuesta["routes"][0]["summary"]["ascent"] #Desnivel positivo acumulado
    except KeyError as e:
        st.error(f"Error al procesar la respuesta de OpenRouteService. Falta la clave: {e}")
        return None, None, None
    except TypeError as e:
         st.error(f"Error al procesar la respuesta de OpenRouteService. Error de tipo: {e}.  Aseg√∫rese de que los datos de la ruta son v√°lidos")
         return None, None, None


    return distancia_total, tiempo_total, desnivel_positivo

# Funci√≥n para obtener el clima con OpenWeatherMap, eligiendo la hora m√°s cercana hacia arriba
def obtener_clima(lat, lon, fecha_hora):
    # Convertir a UTC
    local_timezone = pytz.timezone("America/Santiago")  # Reemplaza con tu zona horaria local
    fecha_hora_local = local_timezone.localize(fecha_hora)
    fecha_hora_utc = fecha_hora_local.astimezone(pytz.utc)

    # Forzar el a√±o 2025
    fecha_hora_utc = fecha_hora_utc.replace(year=2025)

    url = f"https://api.openweathermap.org/data/2.5/forecast?lat={lat}&lon={lon}&appid={OWM_API_KEY}&units=metric&lang=es"
    try:
        respuesta = requests.get(url).json()
    except requests.exceptions.RequestException as e:
        st.error(f"Error de conexi√≥n a OpenWeatherMap Forecast API: {e}")
        return {"temperatura": "N/A", "condiciones": "No disponible", "viento": "N/A"}, fecha_hora

    if respuesta.get("cod") != "200":
        st.warning(f"Error al obtener el clima: C√≥digo {respuesta.get('cod')}")
        return {"temperatura": "N/A", "condiciones": "No disponible", "viento": "N/A"}, fecha_hora

    # Filtrar solo pron√≥sticos con timestamps en el futuro (hacia arriba)
    predicciones_futuras = [p for p in respuesta["list"] if datetime.utcfromtimestamp(p["dt"]) >= fecha_hora_utc]

    if not predicciones_futuras:
        st.warning("No se encontraron pron√≥sticos futuros.")
        return {"temperatura": "N/A", "condiciones": "No disponible", "viento": "N/A"}, fecha_hora

    mejor_prediccion = min(predicciones_futuras, key=lambda x: datetime.utcfromtimestamp(x["dt"]))

    # Convertir velocidad del viento de m/s a km/h (1 m/s = 3.6 km/h)
    viento_kmh = round(mejor_prediccion["wind"]["speed"] * 3.6, 1)

    return {
        "temperatura": int(mejor_prediccion['main']['temp']),  # Temperatura sin decimales
        "condiciones": mejor_prediccion["weather"][0]["description"].capitalize(),
        "viento": viento_kmh  # Velocidad del viento en km/h
    }, fecha_hora

# Funci√≥n para generar recomendaciones usando el LLM
def generar_recomendacion_con_llm(climas):
    # Crear un resumen de los datos de clima
    resumen_clima = "\n".join(
        f"- {clima['nombre']} ({clima['hora_estimada'].strftime('%H:%M')}): {clima['clima']['condiciones']}, "
        f"Temperatura: {clima['clima']['temperatura']}¬∞C, Viento: {clima['clima']['viento']} km/h"
        for clima in climas
    )

    # Crear el prompt para el LLM
    prompt = [
        {"role": "system", "content": "Eres un experto en ciclismo de nivel avanzado. Genera una recomendaci√≥n breve de la ropa requerida seg√∫n el clima (tricota, chaqueta, calza larga o corta, manguillas y pierneras) y accesorios como multi-herramietasm o camara de repuesto, verificar carga de elementos electronicos. Ademas, si la salida es larga recomendar una cantidad de geles y carbohidratos por hora."},
        {"role": "user", "content": f"Datos del clima en los puntos de la ruta:\n"
                                    f"{resumen_clima}\n\n"
                                    f"Por favor, genera una recomendaci√≥n breve y experta enfocada en la ropa, alimentaci√≥n y accesorios m√°s adecuada para las condiciones clim√°ticas del viaje. Usa un formato de checklist. No entregues notas extras. NO recomiendes bidon de agua. No recomiendes bateria externa para cargar."}
    ]

    # Convertir el prompt y obtener la respuesta del LLM
    lc_messages = convert_openai_messages(prompt)
    try:
        response = ChatOpenAI(model='gpt-4o-mini', openai_api_key=OPENAI_API_KEY).invoke(lc_messages).content
    except Exception as e:
        st.error(f"Error al invocar el modelo de lenguaje: {e}")
        return "No se pudo generar la recomendaci√≥n."

    return response

# Interfaz de Streamlit
st.title("Planificador de Rutas de Bicicleta en Chile üö¥‚Äç‚ôÇÔ∏è")

# Campo de entrada sin mensaje precargado
query = st.text_input("Ingresa tu ruta (Pron√≥stico m√°ximo a 5 d√≠as):", placeholder="Ej: Saldr√© a pedalear el 8 de febrero del 2025 a las 8:00 desde providencia a farellones, volviendo a providencia", key="input")

# Funci√≥n para limpiar las variables de sesi√≥n dependientes del prompt
def limpiar_variables_sesion():
    st.session_state['extracted_data'] = None
    st.session_state['hora_salida'] = None
    st.session_state['puntos'] = {"inicio": {}, "destino": {}, "intermedios": []}
    st.session_state['distancia'] = None
    st.session_state['tiempo_estimado'] = None
    st.session_state['desnivel_positivo'] = None
    st.session_state['climas'] = []

# Llamar a la funci√≥n de limpieza al cambiar el prompt
if 'previous_query' not in st.session_state:
    st.session_state['previous_query'] = ""

if query != st.session_state['previous_query']:
    limpiar_variables_sesion()
    st.session_state['previous_query'] = query

# Inicializar variables de sesi√≥n (solo si no existen)
if 'extracted_data' not in st.session_state:
    st.session_state['extracted_data'] = None
if 'hora_salida' not in st.session_state:
    st.session_state['hora_salida'] = None
if 'puntos' not in st.session_state:
    st.session_state['puntos'] = {"inicio": {}, "destino": {}, "intermedios": []}
if 'distancia' not in st.session_state:
    st.session_state['distancia'] = None
if 'tiempo_estimado' not in st.session_state:
    st.session_state['tiempo_estimado'] = None
if 'desnivel_positivo' not in st.session_state:
    st.session_state['desnivel_positivo'] = None
if 'climas' not in st.session_state:
    st.session_state['climas'] = []


# Funci√≥n para extraer datos con el LLM
def extraer_datos(query):
    extract_prompt = [
        {"role": "system", "content": "Extrae los siguientes datos en **JSON puro**, sin explicaciones:\n"
         "{\n"
         "  \"hora_salida\": \"YYYY-MM-DD HH:MM\",\n"
         "  \"lugares\": {\n"
         "    \"inicio\": \"Nombre del lugar de inicio\",\n"
         "    \"intermedios\": [\"Nombre del punto intermedio opcional 1\", \"Nombre del punto intermedio opcional 2\"],\n"
         "    \"destino\": \"Nombre del destino final\"\n"
         "  }\n"
         "}"
        },
        {"role": "user", "content": query}
    ]

    lc_messages = convert_openai_messages(extract_prompt)
    try:
        response = ChatOpenAI(model='gpt-4', openai_api_key=OPENAI_API_KEY).invoke(lc_messages).content
    except Exception as e:
        st.error(f"Error al invocar el modelo de lenguaje: {e}")
        return None

    match = re.search(r"\{.*\}", response, re.DOTALL)
    if match:
        try:
            extracted_data = json.loads(match.group(0))
            return extracted_data
        except json.JSONDecodeError:
            st.error("Error al decodificar JSON. Respuesta del modelo: " + response)
            return None
    else:
        st.error("No se encontr√≥ JSON en la respuesta del modelo.")
        return None

# Planificar la ruta autom√°ticamente al presionar Enter
if query:
    st.session_state['extracted_data'] = extraer_datos(query)

    if not st.session_state['extracted_data']:
        st.info("Por favor, proporciona m√°s detalles sobre tu ruta (fecha, hora, puntos de inicio/fin).")
        st.stop() # Detiene la ejecuci√≥n si no hay datos extra√≠dos

    # Verificar si la hora de salida est√° presente
    if 'hora_salida' not in st.session_state['extracted_data'] or not st.session_state['extracted_data']['hora_salida']:
        st.info("Por favor, especifica la hora de salida en tu ruta.")
        st.stop()
    else:
        # Intentar convertir la hora de salida
        try:
            st.session_state['hora_salida'] = datetime.strptime(st.session_state['extracted_data']["hora_salida"], "%Y-%m-%d %H:%M")
        except ValueError:
            st.info("Por favor, especifica en el mensaje la hora de salida en tu ruta con el formato AAAA-MM-DD HH:MM.")
            st.stop()

    # Obtener coordenadas de los puntos
    if not st.session_state['puntos']['inicio'].get('nombre'):
        if 'inicio' not in st.session_state['extracted_data']['lugares']:
             st.info("Por favor, especifica el punto de inicio de tu ruta.")
             st.stop()

        st.session_state['puntos']['inicio']['nombre'] = st.session_state['extracted_data']['lugares']['inicio']
        st.session_state['puntos']['inicio']['lat'], st.session_state['puntos']['inicio']['lon'] = obtener_coordenadas(st.session_state['puntos']['inicio']['nombre'])

    if not st.session_state['puntos']['destino'].get('nombre'):
        if 'destino' not in st.session_state['extracted_data']['lugares']:
             st.info("Por favor, especifica el destino de tu ruta.")
             st.stop()

        st.session_state['puntos']['destino']['nombre'] = st.session_state['extracted_data']['lugares']['destino']
        st.session_state['puntos']['destino']['lat'], st.session_state['puntos']['destino']['lon'] = obtener_coordenadas(st.session_state['puntos']['destino']['nombre'])

    if "intermedios" in st.session_state['extracted_data']['lugares'] and st.session_state['extracted_data']['lugares']['intermedios']:
        for intermedio in st.session_state['extracted_data']['lugares']['intermedios']:
            if not any(p['nombre'] == intermedio for p in st.session_state['puntos']['intermedios']):
                lat, lon = obtener_coordenadas(intermedio)
                if lat and lon:
                    st.session_state['puntos']['intermedios'].append({"nombre": intermedio, "lat": lat, "lon": lon})
                else:
                    st.warning(f"No se pudieron obtener coordenadas para el punto intermedio: {intermedio}")

    # Calcular distancia y tiempo
    if not st.session_state['distancia'] or not st.session_state['tiempo_estimado'] or st.session_state['desnivel_positivo'] is None:
        st.session_state['distancia'], st.session_state['tiempo_estimado'], st.session_state['desnivel_positivo'] = calcular_distancia_tiempo(st.session_state['puntos'])

    # Aplicar ajuste manual al desnivel positivo
    if st.session_state['desnivel_positivo'] is not None:
        desnivel_ajustado = st.session_state['desnivel_positivo'] / 2
        rango_minimo = round(desnivel_ajustado - 300, 2)
        rango_maximo = round(desnivel_ajustado + 100, 2)
    else:
        desnivel_ajustado = None
        rango_minimo = None
        rango_maximo = None
        st.warning("No se pudo calcular el desnivel positivo.")

    # Obtener clima en los puntos clave
    # Forzar a√±o 2025
    st.session_state['hora_salida'] = st.session_state['hora_salida'].replace(year=2025)

    st.session_state['climas'] = []

    # Clima en el inicio
    clima_inicio, fecha_inicio_api = obtener_clima(st.session_state['puntos']['inicio']['lat'], st.session_state['puntos']['inicio']['lon'], st.session_state['hora_salida'])
    st.session_state['climas'].append({"nombre": st.session_state['puntos']['inicio']['nombre'], "clima": clima_inicio, "hora_estimada": st.session_state['hora_salida']})

    # Clima en los puntos intermedios
    for i, punto in enumerate(st.session_state['puntos']['intermedios']):
        tiempo_parcial = (i + 1) * (st.session_state['tiempo_estimado'] / (len(st.session_state['puntos']['intermedios']) + 1)) if st.session_state['tiempo_estimado'] else 0
        hora_estimada = st.session_state['hora_salida'] + timedelta(hours=tiempo_parcial)

        # Forzar a√±o 2025
        hora_estimada = hora_estimada.replace(year=2025)

        clima_intermedio, fecha_intermedio_api = obtener_clima(punto['lat'], punto['lon'], hora_estimada)
        st.session_state['climas'].append({"nombre": punto['nombre'], "clima": clima_intermedio, "hora_estimada": hora_estimada})

    # Clima en el destino
    hora_destino = st.session_state['hora_salida'] + timedelta(st.session_state['tiempo_estimado'] if st.session_state['tiempo_estimado'] else timedelta(0))

    # Forzar a√±o 2025
    hora_destino = hora_destino.replace(year=2025)

    clima_destino, fecha_destino_api = obtener_clima(st.session_state['puntos']['destino']['lat'], st.session_state['puntos']['destino']['lon'], hora_destino)
    st.session_state['climas'].append({"nombre": st.session_state['puntos']['destino']['nombre'], "clima": clima_destino, "hora_estimada": hora_destino})

    # Mostrar resultados de manera org√°nica
    st.success("### Resumen de la ruta:")
    if 'fecha_inicio_api' in locals():
        st.write(f"Fecha de consulta a la API OpenWeather: {fecha_inicio_api.strftime('%Y-%m-%d')}")  # Mostrar la fecha usada
    if st.session_state['distancia']:
        st.write(f"üö¥‚Äç‚ôÇÔ∏è **Distancia total:** {st.session_state['distancia']:.2f} km")
    else:
        st.warning("No se pudo calcular la distancia.")

    if st.session_state['tiempo_estimado']:
        st.write(f"‚è≥ **Tiempo estimado:** {st.session_state['tiempo_estimado']:.2f} horas")
    else:
        st.warning("No se pudo calcular el tiempo estimado.")

    if rango_minimo is not None and rango_maximo is not None:
        st.write(f"üìà **Rango desnivel estimado:** {rango_minimo} - {rango_maximo} metros")
    else:
        st.warning("No se pudo calcular el desnivel estimado.")
    st.write("---")

    st.write("### Clima en los puntos de la ruta:")
    for clima in st.session_state['climas']:
        st.write(
            f"üìç **{clima['nombre']}** ({clima['hora_estimada'].strftime('%H:%M')}): "
            f"{clima['clima']['condiciones']}, Temperatura: {clima['clima']['temperatura']}¬∞C, "
            f"Viento: {clima['clima']['viento']} km/h"
        )
    st.write("---")

    # Generar y mostrar recomendaci√≥n final usando el LLM
    recomendacion = generar_recomendacion_con_llm(st.session_state['climas'])
    st.write("### Recomendaci√≥n T√©cnica (Ropa y Alimentaci√≥n):")
    st.info(recomendacion)
